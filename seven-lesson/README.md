# Седьмой урок
## План
1. Вектор
2. Матрица
3. Практика

### 1)Вектор
Самое простое определение вектора. Вектор - это направление. Вектор может иметь любую размерность. Если вектор двухкомпонентный, то он описывает направление на плоскости (или на 2D графике), если вектор трехкомпонентный, то он описывает направление в трехмерном мире.

![](https://hsto.org/files/fc2/7d1/5f8/fc27d15f81174d15916b453410eb9582.png)

Когда математики описывают вектора, они предпочитают использовать символы нижнего регистра с небольшой черточкой сверху. Пример:

![](https://hsto.org/files/ead/689/f5e/ead689f5e38d4eafa72dff7d5a39c7e0.png)

Поскольку вектора зачастую описывают направление — то иногда их тяжело представить в виде позиции. Обычно мы визуализируем вектор следующим образом: мы устанавливаем центр в (0, 0, 0), а затем указываем направление, описанное точкой. Таким образом получается позиционный вектор (также мы можем взять за центр другую точку, а потом сказать “Этот вектор указывает на точку в пространстве из этой точки”). Позиционный вектор (3, 5) будет указывать на точку (3, 5) на графе с основанием (0, 0). С помощью векторов мы можем описывать как направления так и позиции в двухмерном и трехмерном пространствах.

### Скалярные векторные операции
Скаляр — это одно число (или однокомпонентный вектор, если вы хотите продолжать работать с векторами). Во время сложения/вычитания/умножения или деления вектора на скаляр мы просто складываем/вычитаем/умножаем или делим каждый элемент вектора на этот скаляр. Пример:

![](https://hsto.org/files/cca/ec6/e9d/ccaec6e9db40474eae499f792369cdbe.png)

Где вместо сложения может быть вычитание, умножение или деление.

### Обратный вектор
Обращение (отрицание) вектора — это получение вектора, чье направление противоположно исходному. Обратный вектор для вектора, указывающего на северо-восток, будет вектор, указывающий на юго-запад. Для обращения вектора мы просто умножаем вектор на -1. Пример:

![](https://hsto.org/files/2f8/6ae/e43/2f86aee4331046b396f63b0e27d02338.png)

### Сложение и вычитание
Сложение двух векторов производится покомпонентно. Пример:

![](https://hsto.org/files/406/f3b/4b6/406f3b4b640e489cab8e1aca60015ba4.png)

Визуально сумма векторов v=(4,2) и k=(1,2) выглядит так:

![](https://hsto.org/files/8d1/d38/519/8d1d3851982542eba1f3fc7f9e77e86d.png)

Также как и с обычным сложением и вычитанием, вычитание векторов — это тоже сложение, но с обратным вторым вектором:

![](https://hsto.org/files/02f/ee2/703/02fee27030124fb68c90ffa3825bc383.png)

Вычитание векторов друг из друга порождают вектор, который является разницей в позициях операндов:

![](https://hsto.org/files/cb9/d25/0fa/cb9d250fac344a78972079869fd07898.png)

### Длина
Для получения длины (модуля) вектора мы используем теорему Пифагора, которые вы, возможно, помните со школы. Вектор образует треугольник, если представить его компоненты в качестве сторон треугольника:
![](https://hsto.org/files/d1e/e3e/236/d1ee3e2362d24a91a086c60ea156f7e3.png)

Поскольку длина сторон (x, y) известна, и мы хотим узнать длину гипотенузы — то мы делаем это следующим образом:

![](https://hsto.org/files/7ab/9e6/8cb/7ab9e68cbd1e4459bad6bb0e116437a6.png)

Где ||v|| — это длина вектора v. Такая формула легко расширяется в 3D добалением z^2. Пример расчета длины:
![](https://hsto.org/files/6e1/323/51d/6e132351d43045b9ad059d4cd7950eeb.png)

Вычисленное значение: 4.47

### Умножение вектора на вектор
Умножение двух векторов выполняется довольно странно. Нормальное умножение не применимо, поскольку оно не имеет визуального смысла, но у нас есть 2 специфических подхода, из которых можно выбирать во время умножения: первый — скалярное произведение, которое изображается как точка, а второе — векторное произведение, которое изображается как крест.

### Скалярное произведение
Скалярное произведение двух векторов эквивалентно скалярному произведению длин этих векторов, умноженное на косинус угла между ними. Если это предложение сбило вас с толку, то посмотрите на формулу:

![](https://hsto.org/files/482/fd3/bdc/482fd3bdc8fe4341b50ab639e244c3ac.png)

Так как же считать скалярное произведение? Скалярное произведение — это умножение компонентов векторов и последующее сложение результатов. Пример:
![](https://hsto.org/files/b89/f81/a00/b89f81a00f5f4a58b594deb06e6b9ed9.png)


Для вычисления угла между векторами нам потребуется обратить функцию косинуса (cos^-1) в данном случае — это 143.1 градуса. Таким образом мы эффективно вычислили угол между этими двумя векторами. Скалярное произведение очень полезно во время работы со светом.

### Векторное произведение
Векторное произведение возможно только в трехмерном пространстве и принимает на вход два непараллельных вектора, а возвращает вектор, который ортогонален входным. Если входные вектора ортогональны друг другу, то векторное произведение создаст 3 ортогональных вектора. Далее вы узнаете, почему это может быть полезно. Следующее изображение показывает как это выглядит трехмерном пространстве:

![](https://habrastorage.org/files/422/528/4c1/4225284c1f5d4e58bb0bfdfd27de0604.png)

В отличии от других операций, векторное произведение не очень интуитивно без углубления в линейную алгебру, так что лучше просто запомнить формулу. Ниже представлено векторное произведение между двумя ортогональными векторами A и B.

![](https://hsto.org/files/5e9/599/44d/5e959944d6284b82a62b932297313739.png)

Как вы можете видеть, в этой формуле не очень много смысла. В любом случае после всех этих шагов вы получите вектор, который будет ортогонален входным.

### 2)Матрицы
Теперь, после того как мы обсудили почти все на счет векторов, настало время углубиться в матрицы. Матрица, обычно, это четырехугольних из набора чисел, символов и/или выражений. Вот пример матрицы 2х3:

![](https://hsto.org/files/706/b8a/18b/706b8a18b7db4e01a81a01eba5d4e1c8.png)

Доступ к элементам матрицы осуществляется с помощью (i,j), где i — это строка, а j — это столбец. Вот почему матрица выше называется 2х3 (3 столбца и 2 строки). Такая система — обратна той, что используется в 2D графах (x, y). Для получения значения 4 из матрицы выше, мы должны указать индекс (2, 1) (вторая строка, первый столбец).

### Сложение и вычитание

Сложение матрицы со скаляром выполняется следующим образом:

![](https://hsto.org/files/e02/b5b/fa0/e02b5bfa006f4e13a6191725d2c636af.png)

Скаляр просто прибавляется во всем элементам матрицы. Тоже самое происходит и при вычитании:

![](https://hsto.org/files/0d5/d85/513/0d5d855135414aef9886488b4efb8a0f.png)

Сложение и вычитание между двумя матрицами выполняется поэлементно. Таким образом операции сложения и вычитания могут быть применены только к матрицам одинакового размера. Пример:

![](https://hsto.org/files/533/646/971/533646971a28467dad87b9851f4c0a32.png)

Тоже самое, только с вычитанием:

![](https://hsto.org/files/fa0/85c/f4c/fa085cf4ce9e4c48a8a776871805a7b1.png)

### Умножение матрицы на скаляр
Также как сложение и вычитание, умножение матрицы на скаляр производится умножением каждого элемента матрицы на скаляр. Пример:

![](https://hsto.org/files/16a/880/e02/16a880e021f5456eb87da5c6cf8c23fa.png)

### Умножение матриц
Умножение матриц не очень сложное, но и не такое простое. Умножение имеет несколько ограничений:
1. Вы можете умножать только матрицы, где число столбцов первой совпадает с числом строк второй матрицы.
2. Умножение матриц не коммутативно. A * B != B * A.

Вот пример умножения двух матриц 2х2:
![](https://hsto.org/files/074/04d/eac/07404deac8b74800bd07bc7990960c27.png)

Сейчас, возможно вы пытаетесь понять, что же тут вообще происходит? Умножение матриц — это комбинация из нормального умножения и сложения с использованием строк левой матрицы со столбцами правой матрицы. Следующее изображение должно внести немного ясности:

![](https://hsto.org/files/4c5/54a/02b/4c554a02b2294220bbc970af7d7ea355.png)

В результате получается матрица размером (n, m), где n — количество строк в левой матрице, а m — количество столбцов в правой матрице.

![](https://hsto.org/files/275/396/c24/275396c24e3c4b1ea5e3310cb1edf720.png)

### Умножение матрицы на вектор
Мы уже использовали вектора в прошлых уроках. Мы использовали их, чтобы представлять позиции, цвета и текстурные координаты. Теперь давайте немного углубимся в кроличью нору и расскажем, что вектор — это на самом деле просто Nx1 матрица, где N — это количество компонентов вектора. Если вы чуть подумаете об этом — это имеет смысл. Вектора, прямо как матрицы — массив чисел, но только с 1 колонкой. И как же нам поможет эта информация? Что же, если у нас есть матрица MxN мы сможем ее умножить на Nx1 вектор, так как количество столбцов матрицы равно количеству строк вектора.

Но зачем нам вообще уметь умножать матрицу на вектор? Довольно много различных 3D/2D трансформаций можно выполнить, умножая матрицу на вектор, получая измененный вектор.

### Единичная матрица
В OpenGL обычно работают с матрицами трансформации размерами 4х4 по той причине, что большинство векторов имеет 4 компонента. Самая простая матрица трансформации которую можно обсудить — это единичная матрица. Единичная матрица — это NxN матрица, заполненная нулями, но с 1 по диагонали. Как мы можете заметить эта матрица совершенно не изменяет вектор:

![](https://hsto.org/files/e0a/b15/18e/e0ab1518ebea46e7922bf4c61c8be2d9.png)

Вектор выглядит нетронутым. Это становится очевидно из правил умножения: первый результирующий элемент — это каждый элемент первой строки матрицы, умноженные на каждый элемент вектора. Поскольку каждый элемент строки равен 0, кроме первого — то мы получаем 1 * 1 + 0 * 2 + 0 * 3 + 0 * 4 = 1. Тоже самое применяется и к остальным 3 элементам вектора.

### Матрица масштабирования
Когда мы масштабируем вектор — мы увеличиваем длину стрелки на величину масштабирования, сохраняя направление. Пока мы работаем в 2 или 3 размерностях мы можем определить масштабирование вектором из 2 или 3 величин, каждая из которых масштабирует одну из осей (x, y или z).

Давайте попробуем масштабировать вектор v = (3,2). Мы будем масштабировать вектор по оси x на 0.5, что сделает его в 2 раза уже; и масштабируем вектор по оси y на 2, что увеличит высоту в 2 раза. Давайте посмотрим как будет выглядеть если мы масштабируем вектор на (0.5, 2). Запишем результат в виде s.

![](https://hsto.org/files/a3f/a6e/e4f/a3fa6ee4f1da4b779c013cfe0e8a7e0d.png)

Помните, что OpenGL зачастую работает в 3D пространстве, соответственно для 2D можно оставить Z координату, равную 1. Операция масштабирования, которую мы только что выполнили, является неоднородной, поскольку величина масштабирования для каждой оси различается. Если бы величина масштабирования была бы одинаковой — то такое преобразование называется однородным.

Давайте построим матрицу трансформации которая выполнит для нас масштабирование. Мы уже увидели на единичной матрице, что диагональный элемент будет умножен на соответствующий элемент вектора. Что если мы заменим единицы в единичной матрице на тройки? В таком случае мы умножим все элементы вектора на это значение. Соответственно если мы представим величины масштабирования как (S1, S2, S3) то мы сможем определить матрицу масштабирования для любого вектора (x, y, z):

![](https://hsto.org/files/176/58d/4e5/17658d4e58c34d679a7e88724c2284db.png)

Заметьте, что 4 элемент вектора равняется 1. Этот компонент обозначается как w и будет потом использован для других задач.

### Матрица сдвига
Сдвиг — это процесс добавления одного вектора к другому для получения нового вектора с другой позицией, то-есть сдвиг вектора на основании вектора сдвига. Мы уже обсуждали сложение векторов, поэтому для вас это не будет чем-то новым.
Также как и с матрицей масштабирования в матрице 4х4 есть несколько позиций для выполнения требуемых операций, для сдвига — это верхние 3 элемента четвертой колонки. Если мы представим вектор сдвига как (Tx, Ty, Tz) — то мы можем определить матрицу сдвига следующим образом:

![](https://hsto.org/files/68c/2ae/5bc/68c2ae5bca1d40438498f01c063b4fcd.png)

Это работает, потому что все значения вектора умножаются на w компонент вектора и складываются с начальным значениями. Это было бы невозможно при использовании матриц 3х3.

### Матрица вращения
Последние пару трансформаций были довольно просты для понимания и представления в 2D или 3D пространстве, но вращения немного более заковыристые.

Для начала давайте определим что вообще такое — вращение вектора. Вращение в 2D и 3D определяется углом. Угол может выражаться в углах или в радианах, в которых полный оборот — это 360 градусов или 2Pi соответственно

Большинство вращательных функций требует угол в радианах, но благо преобразование из одной системы в другую выполнить довольно просто:
Градусы = радианы * (180.0f / PI)
Радианы = градусы * (PI / 180.0f)
Где PI примерно 3.14159265359

Вращение на половину круга — требует от нас вращения на 360/2 = 180 градусов. Вращение на 1/5 направо требует от нас вращение на 360/5 = 72 градуса направо. Вот пример обычного 2D вектора, где v повернут на 72 градуса направо от k.

![](https://hsto.org/files/291/99e/cbf/29199ecbfe804b91850749110018dd9f.png)

Вращение в 3D описывается углом и осью вращения. Угол определяет то насколько вектор будет повернут относительно данной оси. При вращении 2D векторов в 3D мире, к примеру, мы установим ось вращения — Z.

С помощью тригонометрии мы можем преобразовывать вектора в повернутые на определенный угол. Обычно это делается хитрой комбинацией sin и cos функций. 

Матрица вращения определена для каждой оси в 3D пространстве, где угол показан как тета.
Матрица вращения вокруг оси X:

![](https://hsto.org/files/d50/22a/48e/d5022a48e910426b875ac78bde60acf6.png)

Матрица вращения вокруг оси Y:

![](https://hsto.org/files/caf/325/15b/caf32515b86b4cfdbfddec2c0ecc8188.png)

Матрица вращения вокруг оси Z:

![](https://hsto.org/files/b28/2fa/c76/b282fac763104e5f8ea27b43c5e28545.png)

### Комбинирование матриц
Для того, чтобы достичь максимальной полезности использования матриц для трансформаций мы должны комбинировать матрицы трансформации в одну матрицу. Давайте посмотрим, сможем ли мы сгенерировать матрицу трансформации, которая будет в себя включать несколько трансформаций. Например у нас есть вектор (x, y, z) и мы хотим масштабировать его в 2 раза и сдвинуть на (1, 2, 3). Для этого нам потребуются матрицы масштабирования и смещения. В результате мы получим что-то вроде:

![](https://hsto.org/files/ce1/b4b/138/ce1b4b1386d94a2d9626231004abf666.png)

Заметьте, что во время умножения матриц мы в начале выполняем сдвиг, а потом масштабирование. Умножение матриц не коммутативно, что означает, что порядок умножения важен. Во время умножения матриц правая матрица умножается на вектор, поэтому вам надо читать умножения справа налево. Рекомендуется в начале масштабировать, затем вращать и в конце сдвигать, во время объединения матриц, в ином случае они могут отрицать друг-друга. Например если вы в начале выполните сдвиг, а затем масштабирование, то матрица сдвига тоже будет масштабировать!

В итоге матрица трансформации применяется следующим образом:

![](https://hsto.org/files/ccd/303/e8b/ccd303e8b49b45cb8b15f1c4d9c94da9.png)

### 3)Практика
GLM это аббревиатура от OpenGL Mathematics. Эта библиотека является заголовочной, что означает, что нам достаточно подключить требуемые заголовочные файлы. Не нужно заморачиваться ни с линковкой ни с компиляцией. GLM можно скачать с официального сайта. Скопируйте корневую директорию с заголовочными файлами в вашу папку includes и можно начинать.

Большая часть функциональности GLM можно найти в 3 заголовочных файлах:

```cpp
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
```
Давайте посмотрим, сможем ли мы применить наши знания в преобразованиях для сдвига вектора (1, 0, 0) на (1, 1, 0) (заметьте, что мы обозначили из как glm::vec4 с гомогенной координатой равной 1.0):

```cpp
glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);
glm::mat4 trans;
trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));
vec = trans * vec;
std::cout << vec.x << vec.y << vec.z << std::endl;
```

В начале мы создали вектор названный vec с помощью встроенного в GLM векторного класса. Затем мы определяем mat4, которая является единичной матрицей 4х4. Затем мы создаем матрицу трансформации, передавая нашу единичную матрицу в функцию glm::translate, вместе с вектором сдвига.
Затем мы умножаем наш вектор на матрицу трансформации и выводим результат. Если вы все еще помните как работает матрица сдвига — то вы понимаете, что результирующий вектор должен быть (1+1, 0+1, 0+0), который равен (2, 1, 0). Код выше выводит 210, что означает, что матрица сдвига сделала свою работу.

Давайте попробуем сделать нечто более интересное и попробуем масштабировать, а затем повернуть объект из прошлого урока. В начале мы повернем контейнер на 90 градусов против часовой стрелки. Затем масштабируем его на 0.5 для того, чтобы уменьшить его в 2 раза. Давайте построим матрицу трансформации для этого.

```cpp
glm::mat4 trans;
trans = glm::rotate(trans, 90.0f, glm::vec3(0.0, 0.0, 1.0));
trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));  
```
В начале мы уменьшаем контейнер на 0.5, по каждой оси, а затем поворачиваем контейнер на 90 градусов по Z координате. Заметьте, что текстура также повернулась. Поскольку мы передаем матрицу в каждую из GLM функций, GLM автоматически перемножает матрицы, в результате получая матрицу трансформации.

Следующий большой вопрос — это как передать матрицу трансформации в шейдер? Ранее мы уже говорили, что GLSL имеет тип mat4. Так что нам осталось принять mat4 в качестве uniform переменной и умножить вектор позиции на эту матрицу.

```cpp
#version 330 core
layout (location = 0) in vec3 position;
layout (location = 1) in vec3 color;
layout (location = 2) in vec2 texCoord;

out vec3 ourColor;
out vec2 TexCoord;

uniform mat4 transform;

void main()
{
    gl_Position = transform * vec4(position, 1.0f);
    ourColor = color;
    TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);
} 
```

Мы добавили uniform и умножили позиционный вектор на трансформационную матрицу перед тем как передать ее в gl_Position. Наш контейнер теперь должен стать меньше в 2 раза и повернуться на 90 градусов. Но нам все еще надо передать трансформационную матрицу в шейдер?

```cpp
GLuint transformLoc = glGetUniformLocation(ourShader.Program, "transform");
glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));
```

В начале мы получаем позицию uniform переменной и затем отправляем в нее данные матрицы с помощью функции glUniform с постфиксом Matrix4fv. Первый аргумент должен быть позицией переменной. Второй аргумент сообщает OpenGL сколько матриц мы собираемся отправлять, в нашем случае 1. Третий аргумент говорит требуется ли транспонировать матрицу. OpenGL разработчики часто используют внутренних матричный формат, называемый column-major ordering, который используется в GLM по умолчанию, поэтому нам не требуется транспонировать матрицы, мы можем оставить GL_FALSE. Последний параметр — это, собственно, данные, но GLM не хранит данные точно так как OpenGL хочет их видеть, поэтому мы преобразовываем их с помощью value_ptr.

Мы создали матрицу трансформации, объявили uniform в вершинном шейдере, и отправили матрицу в шейдере с помощью которой мы корректируем вершинные координаты. В результате должно получиться что-то вроде этого:

![](https://hsto.org/files/2f0/43d/676/2f043d676a4a45fb970eccba9eb3ed97.png)

Отлично! Наш контейнер действительно повернут налево и стал в 2 раза меньше, так что трансформация прошла успешно. А теперь давайте заставим вращаться наш контейнер в реальном времени, а также передвинем его в нижний правый угол. Для того, чтобы это сделать придется производить вычисления при каждой итерации основного цикла. Мы используем функцию GLFW для получения времени, чтобы менять угол со временем:

```cpp
glm::mat4 trans;
trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
trans = glm::rotate(trans,(GLfloat)glfwGetTime() * 50.0f, glm::vec3(0.0f, 0.0f, 1.0f));
```

Держите в голове, что раньше мы могли объявить матрицу трансформации где угодно, но теперь мы создаем ее при каждой итерации, чтобы мы могли обновлять вращение на каждый кадр. Это значит, что мы должны пересоздавать матрицу трансформации на каждой итерации игрового цикла. Обычно, когда на сцене несколько объектов, то их матрицы трансформации пересоздаются с новыми значениями при каждой итерации отрисовки.

Теперь мы вращаем объект вокруг центра (0, 0, 0), а после этого сдвигаем повернутую версию в нижний-правый угол экрана. Помните, что реальная последовательность применения трансформаций читается в обратном порядке: даже в коде мы в начале сдвигаем, а потом поворачиваем, то трансформации применяются в обратном порядке, в начале поворот, затем сдвиг. Понимание всех этих трансформаций и того как они влияют на объекты довольно затруднительно. Попробуйте поэкспериментировать с трансформациями и вы быстро с ними свыкнитесь.