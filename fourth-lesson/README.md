# Четвертый урок
## План
1. Графический конвейер
2. Передача вершин
3. Вершинный шейдер
4. Фрагментный шейдер
5. Шейдерная программа
6. Связывание вершинных атрибутов
7. Vertex Array Object
8. Element Buffer Object

------------

### 1)Графический конвейер
OpenGL работает в 3D пространстве, монитор пользователя в свою очередь может отображать только 2D пространства, одна из задач графического конвейера - преобразовать 3D пространство в 2D пространство цветных пикселей на экране.
Этот процесс можно разделить на шесть этапов, каждый этап выполняется с помощью отдельной программы - **шейдера**.
**Шейдер  - ** это программа, которая работает на GPU.
Некоторые шейдер могут создаваться разработчиком, для дальнейшего исполнения.
Этапы графического конвейера:
1. Вершинный шейдер (может создваться разработчиком)
2. Формирование форм
3. Геометрический шейдер (может создваться разработчиком)
4. Растеризация
5. Фрагментный шейдер (может создваться разработчиком)
6. Тесты и смешивание

На вход графическому конвейеру передаются вершинные данные
Вершинные данные - набор вершин. Каждая вершина представлена атрибутами, эти атрибуты включают в себя координаты, цвет, дополнительные параметры и т.д.

Рассмотрим каждый этап графического конвейера.
**1) Вершинный шейдер** - принимает на вход вершину, его задача преобразование одних координат в другие. Данные процесс преобразования называется **нормализацией**. Обычно он сводится к тому, что преобразовывает все координаты в диапазон от -1.0 до 1.0. Об задачи нормализации будет сказано ниже.
**2) Формирование формы** - это этап, которые берет все вершины из вершинного шейдера и преобразует их в фигуру.
**3) Геометрический шейдер** - принимает на вход набор вершин, формирующих примитив. Работает уже с фигурой в целом, способен динамически ее дополнять.
**4) Растеризация** - примитив преобразовывается в пиксельное представление, формируя фрагмент. Растеризация может производится с помощью разных алгоритмов. Два алгоритма растеризации представлены в этом репозитории (DDA-Line, Алгоритм Брезенхэма) https://github.com/Tyutnev/rasterization
**5) Фрагментный шейдер** - вычисление цвета пикселей.
**6) Тесты и смешивание** - проверяет значения прозрачности и смешивает цвета.

------------

### 2)Передача вершин
Для отрисовки, нужно передать данные о вершинах, эти данные нужно передавать в трехмерном пространстве (x, y, z). OpenGL не преобразовывает все переданные ему 3D координаты в 2D пиксели на экране; OpenGL только обрабатывает 3D координаты в определенном промежутке между -1.0 и 1.0 по всем 3 координатам (x, y и z). Все такие координаты называются координатами, нормализованными под устройство (или просто нормализованными).
```cpp
//Определим вершины треугольника
//Данные о вершинах будем хранить в куче
GLfloat vertices[] = {
	-0.5f, -0.5f, 0.0f,
	 0.5f, -0.5f, 0.0f,
	 0.0f,  0.5f, 0.0f
};
```
**Нормализованные координаты - ** после того, как вершины будут обработаны в вершинном шейдере, они должны быть нормализованы, то есть находится в пределе от -1.0 до 1.0.
В отличии от экранных координат, положительное значение оси y указывает наверх, а координаты (0, 0) это центр графа, вместо верхнего левого угла.
![](https://hsto.org/files/b5e/861/5c2/b5e8615c2eac4c488adc727685ce14c8.png)
Ваши NDC координаты будут затем преобразованы в координаты экранного пространства через Viewport с использованием данных, предоставленных через вызов glViewport. Координаты экранного пространства затем трансформируются во фрагменты и подаются на вход фрагментному шейдеру.
После того, как мы определили вершины, мы должны их передать в память GPU, алгоритм передачи:
1.  Определение структуры данных VBO (vertex buffer objects), в которой будут хранится вершины для передачи.
2. Выделение памяти на GPU для VBO.
3. Передача

```cpp
//vertex buffer objects
//Будет хранить вершины нашего треугольника
GLuint VBO;
//Создание буфера
glGenBuffers(1, &VBO);
//Указание о том, что буфер имеет тип VBO
glBindBuffer(GL_ARRAY_BUFFER, VBO);
```
Скопируем данные из выше описанного массива vertices в VBO
```cpp
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```
Рассмотрим детальную эту функцию:
1.Тип буффера, в который будут записаны данных, в нашем случае это VBO.
2. Размер данных, которые будут скопированы
3. Данные
4. Указание видеокарте на то, как она должна работать с данными. Существует три режима работы с данными: **GL_STATIC_DRAW** - данные не будут изменяться, или будут это делать очень редко. **GL_DYNAMIC_DRAW** - данные будут меняться.  **GL_STREAM_DRAW** - данные будут меняться при каждой отрисовке.

### 3)Вершинный шейдер
**Вершинный шейдер** - один из програмируемых шейдеров. Шейдеры создаются на Си-подобном языке GLSL. Код шейдера можно задать как простую строку, затем создать объект шейдера и скомпилировать его. Затем из отдельных шейдеров линкуется шейдерная программа.

```cpp
//Установка версии шейдера
//Указание на то, что мы используем Core-profile
#version 330 core

//Указываем входные вершинные атрибуты
//Вершины имеют трехмерные координаты, поэтой причине мы создаем vec3
//Указав layout (location = 0) - задаем положение равное нулю
layout (location = 0) in vec3 position;

void main()
{
    //Для обозначения результата работы вершинного шейдера, мы должны присвоить
    //значение преопределенной переменной gl_Position
    //Это результат работы вершинного шейдера
    //Она имеет тип vec4
    gl_Position = vec4(position.x, position.y, position.z, 1.0);
}
```

Теперь мы можем определить глобальую переменную типа стринг на куче, и сохранить туда данный код.

```cpp
const GLchar* vertexShaderSource = "#version 330 core\n"
						"layout (location = 0) in vec3 position;\n"
						"void main()\n"
						"{\n"
						"gl_Position = vec4(position.x, position.y, position.z, 1.0);\n"
						 "}\0";
```

Скомпилируем созданный шейдер, для этого нужно проделать следующие шаги:
1. Создать объект шейдера.
2. Привязать код шейдера к объекту шейдера
1. Скомпилировать его

```cpp
//Создание объекта шейдера
GLuint vertexShader;
//glCreateShader принимает один аргумент - тип шейдера
//glCreateShader возвращает идентификатор объекта
vertexShader = glCreateShader(GL_VERTEX_SHADER);
//Привязываем исходный код к объекту шейдера
//Аргументы:
//1)Объект шейдера
//2)Количество строк исходного кода шейдера
//3)Исходный код шейдера
//Последний аргумент нам не нужен, будет задан как NULL
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
//Компиляция шейдера
glCompileShader(vertexShader);
```

### 4)Фрагментный шейдер
**Фрагментный шейдер** — это второй и последний шейдер, который нам понадобится, чтобы отрисовать треугольник. Фрагментный шейдер занимается вычислением цветов пикселей. Во имя простоты наш фрагментный шейдер будет выводить только оранжевый цвет.

```cpp
//Задаем версия и Core-profile режим
#version 330 core

//Указываем выходную переменную с помощью ключевого слова out
out vec4 color;

void main()
{
    //Устанавливаем значение переменной color в кодировке RGBA
	color = vec4(1.0f, 0.5f, 0.2f, 1.0f);
}
```

```cpp
//Cборка шейдера происходит аналогично
GLuint fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
glCompileShader(fragmentShader);
```

### 5)Шейдерная программа
**Шейдерная программа** — это объект, являющийся финальным результатом комбинации нескольких шейдеров. Для того, чтобы использовать собранные шейдеры их требуется соединить в объект шейдерной программы, а затем активировать эту программу при отрисовке объектов, и эта программа будет использоваться при вызове команд отрисовки.
При соединении шейдеров в программу, выходные значения одного шейдера сопоставляются с входными значениями другого шейдера.
```cpp
//Создаем шейдерную программу
GLuint shaderProgram;
//glCreateProgram - возвращает идентификатор программы
shaderProgram = glCreateProgram();
//Присоединяем шейдеры к программе
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
//Связываем их
glLinkProgram(shaderProgram);
```

Для использования программы, нужно вызвать:
```cpp
glUseProgram(shaderProgram);
```
Теперь мы можем удалить шейдеры:
```cpp
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
```

### 6)Связывание вершинных атрибутов
Вершинный шейдер позволяет нам указать любые данные в каждый атрибут вершины, но это не значит, что нам придется указывать какой элемент данных относится к какому атрибуту. Это означает, что мы должны сообщить как OpenGL должен интерпретировать вершинные данные перед отрисовкой.
Вершинный буфер:
![](https://hsto.org/files/f8a/ac4/1b5/f8aac41b555b4487a68c8a71dfcf3c55.png)
Зная эти особенности мы можем сообщить OpenGL как он должен интерпретировать вершинные данные. Делается это с помощью функции glVertexAttribPointer:
```cpp
//Первый аргумент указывает, какой элемент шейдера мы хотим настроить
//Мы хотим специфицировать значение аргумента position, 
//позиция которого была указана следующим образом: layout (location = 0).
//Второй аргумент - описывает размер аргумента в шейдере. 
//Поскольку мы использовали vec3 то мы указываем 3.
//Третий аргумент описывает используемый тип данных. 
//Мы указываем GL_FLOAT, поскольку vec в шейдере использует числа с плавающей точкой.
//Четвертый аргумент указывает необходимость нормализовать входные данные.
//Пятый аргумент называется шагом и описывает расстояние между наборами данных
//Последний параметр имеет тип GLvoid* и поэтому требует такое странное приведение типов. 
//Это смещение начала данных в буфере
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
//Включаем атрибут
glEnableVertexAttribArray(0);
```

Теперь отрисовка будет выглядить так:

```cpp
//Копируем массив с вершинами в буфер OpenGL
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// Затем установим указатели на вершинные атрибуты
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
// Используем нашу шейдерную программу
glUseProgram(shaderProgram);
//Теперь уже отрисовываем объект
someOpenGlFunctionThatDrawsOutTriangle();
```

### 7)Vertex Array Object
Объект вершинного массива (VAO) может быть также привязан как и VBO и после этого все последующие вызовы вершинных атрибутов будут храниться в VAO. Преимущество этого метода в том, что нам требуется настроить атрибуты лишь единожды, а все последующие разы будет использована конфигурация VAO.

VAO хранит следующие вызовы:
- Вызовы glEnableVertexAttribArray или glDisableVertexAttribArray
- Конфигурация атрибутов, выполненная через glVertexAttribPointer
- VBO ассоциированные с вершинными атрибутами с помощью glVertexAttribPointer

![](https://hsto.org/files/0b5/11d/dfa/0b511ddfa0f94b4a90f51026869a0d4d.png)

Создание VAO:
```cpp
GLuint VAO;
glGenVertexArrays(1, &VAO);
```
Для того, чтобы использовать VAO все что вам надо сделать — это привязать VAO с помощью glBindVertexArray. Теперь мы должны настроить/привязать требуемые VBO и указатели на атрибуты, а в конце отвязать VAO для последующего использования. И теперь, каждый раз когда мы хотим отрисовать объект мы просто привязываем VAO с требуемыми нам настройками перед отрисовкой объекта.

Наконец, мы можем отрисовать треугольник. Исходный код находится в этой же поддиректории в файле triangle.cpp
